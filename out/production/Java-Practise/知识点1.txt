数组相关类库
1.数组排序：java.util.Arrays.sort(数组名称)

2.数组拷贝（把方法做了一些变形）：
    System.arraycopy(原数组，原数组开始点，目标数组，目标数组开始点，拷贝长度)。
范例：实现数组拷贝
    现在假设有两个数组
        数组一：1、2、3、4、5、6、7、8、9；
        数组二：11、22、33、44、55、66、77、88、99；
    要求拷贝之后的数组二内容为：11、22、33、6、7、8、77、88、99
    System.arraycopy(dataA,5,dataB,3,3);


数据库与简单Java类之间的基本映射关系如下：// 查看newdemo.demo02
    数据实体表设计 = 类的定义； // class 表名
    表中的字段 = 类的成员属性； // newdemo.demo02.表名，public class Emp-->public String getInfo()
    表的外键关联 = 引用关联； //...
    表的一行记录 = 类的一个实例化对象； // demo02.Main
    表的多行记录 = 对象数组。// private Emp emps[];

对于数据表与简单java类之间的映射最好的解决步骤：先抛开所有的关联字段不看，写出类的基本组成，而后在通过应用配置关联字段的关系。
    第一步：分别定义Emp、Dept两个实体类
    第二步：配置所有的关联字段


对象（常量）池
    对象池的主要目的是实现数据的共享处理。以String对象池为例，里面的内容主要就是为了重用，而重用的实际上就属于共享设计，
但是在Java之中对象（常量）池实际上可以分为两种：
    静态常量池：指的是程序（*.class）在加载的时候会自动将此程序之中保存的字符串、普通的常量、类和方法的信息等等，全部进行分配。
    运行时常量池：当一个程序（*.class）加载之后，里面可能有一些变量，这个时候提供的常量池。


Object类对象可以接收所有数据类型，包括基本数据类型、类对象、接口对象、数组。

由于接口描述的是一个公共的定义标准，所以在接口之中所有的抽象方法的访问权限都为public，也就是说写与不写都是一样的


抽象类与接口的区别
No      区别            抽象类                                              接口
1       定义关键字       abstract class 抽象类名称 {}                         interface 接口名称 {}
2       组成            构造、抽象方法、全局常量、普通成员、静态方法、普通方法        抽象方法、全局常量、普通方法、静态方法
3       权限            可以使用各种权限定义 (子类权限要高于父类)                  只能使用public
4       子类使用         子类通过extends关键字可以继承一个抽象类                  子类使用implements关键字可以实现多个接口
5       两者关系         抽象类可以实现若干个接口                                接口不允许继承抽象类，但是允许继承多个父接口
6       使用                           1、抽象类或接口必须定义子类
                                      2、子类一定要覆写抽象类或接口中的全部抽象方法
                                      3、通过子类的向上转型实现抽象类或接口对象实例化

当抽象类和接口都可以使用的情况下优先要考虑接口，因为接口可以避免子类的单继承，因为接口可以避免子类的单继承局限


Enum类中定义的方法
protected Enum(String name,int ordinal)         构造          传入名字和序号
public final String name()                      普通          获得对象名字
public final int ordinal()                      普通          获得对象序号


异常
try{
    // 可能出现异常的语句
} [catch (异常类型 异常对象) {
    // 异常处理
} catch (异常类型 异常对象) {
     // 异常处理
} ... ] [finally{
    不管异常是否处理都要执行 ;
}]


对于Lambda表达式而言，提供有如下几种格式：
    方法没有参数：()->{};
    方法有参数：(参数，参数)->{};
    如果现在只有一行语句返回：(参数，参数)->语句;


对于泛型，在“？”这个通配符的基础之上实际上还提供有两类小的通配符
    ? extends 类：设置泛型的上限;
        例如：定义"? extends Number"：表示该泛型类型只允许设置Number或Number的子类
    ? super 类：设置泛型的下限;
        例如：定义"? super String"：只能够使用String或其父类