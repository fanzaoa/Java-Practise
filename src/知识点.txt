Ctrl+N 按名字搜索类
Ctrl+F 按照文本的内容查找

基本类型：byte,short,int,long,float,double,char,boolean，没String
基本类型自然不用说了，它的值就是一个数字，一个字符或一个布尔值。
**只要不是基本类型就是引用类型**
引用类型：
是一个对象类型，值是什么呢？它的值是指向内存空间的引用，就是地址，所指向的内存中保存着变量所表示的一个值或一组值。如new出来在堆中的就有地址值
地址值一般在计算机中以16进制存储

对于基本类型来说，==是进行数值的比较。
对于引用类型来说，==是进行【地址值】的比较。内容值比较用equals()方法

a++ ,编译时值为a
++a ,编译时值为a+1

口诀：
成员变量：编译看左边，运行还看左边。
成员方法：编译看左边，运行看右边。

成员方法没有static关键词，没有返回值。


导包：也就是指出需要使用的类，在什么位置
import 包名称.类名词；
**对于和当前类属于同一个包的情况，可以省略导包语句不写**
对官方API，只有java.lang包下的内容不需要导包，其他的包都需要import语句。


局部变量和成员变量
1.定义的位置不一样【重点】
局部变量：在方法的内部
成员变量：在方法的外部，直接写在类当中

2.作用范围不一样【重点】
局部变量：只有方法当中才可以使用，出了方法就不能在用
成员变量：整个类全都可以通用。

3.默认值不一样【重点】
局部变量：没有默认值，如果要想使用，必须手动进行赋值
成员变量：如果没有赋值，会有默认值，规则和数组一样

4.内存的位置不一样（了解）
局部变量：位于栈内存
成员变量：位于堆内存

5.生命周期不一样（了解）
局部变量：随着方法进栈而诞生，随着方法出栈而消失
成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失


当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。
如果需要访问本类当中的成员变量，需要使用格式：
this.成员变量名

“通过谁调用的方法，谁就是this。”


构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。
格式：
public 类名称（参数类型 参数名称）{
    方法体
}

注意事项：
1.构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样
2.构造方法不要写返回值类型，连void都不写
3.构造方法不能return一个具体的返回值
4.如果没有编写任何构造方法，那末编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。
public Student(){}
5.一旦编写了至少一个构造方法，那末编译器将不在赠送。


ArrayList当中的常用方法有：

public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。
备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。
但是对于其他集合来说，add添加动作不一定成功

public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。
public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。
public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。


public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false.
        注意事项：
        1.任何对象都能用Object进行接受。
        2.equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。
        3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面。
        推荐："abc".equals(str)       不推荐：str.equals("abc")，因为str为null时，程序会报空指针异常

public boolean equalsIgnoreCase(String str)，忽略大小写，进行内容比较。


String当中与获取相关的常用方法有：

public int length()：获取字符串当中含有的字符个数，拿到字符串长度。
public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。
public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。）
public int indexOf(String str)：查找参数字符串在本字符串当中**首次**出现的索引位置，如果没有放回-1值。

字符串的截取方法：

public String substring(int index):截取从参数位置一直到字符串末尾，返回新字符串。
public String substring(int begin,int end)：截取从begin开始，一直到end结束，中间的字符串。
备注：[begin,end)，包含左边，不包含右边。

String当中与转换相关的常用方法有：

public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。
public byte[] getBytes()：获得当前字符串底层的字节数组。
public String replace(CharSequence oldString,CharSequence new String)：
将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。
备注：CharSequence意思就是说可以接受字符串类型。

分割字符串的方法：
public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分

注意事项：
split方法的参数其实是一个“正则表达式”。
如果按照英文句点”."进行划分，必须写“\\.”（两个）
.在正则表达式中有特殊含义


java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。

public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1,元素2,元素3,...])
public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。

备注：
1.如果是数值，sort默认按照升序从小到大
2.如果是字符串，sort默认按照字母升序
3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。


java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。

public static double abs(double num)：获取绝对值。
public static double ceil(double num)：向上取整。// 51.1-->52.0
public static double floor(double num)：向下取整。// 69.9-->69.0
public static long round(double num)：四舍五入。

Math.PI代表近似的圆周率常量（double）。


在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：

直接通过子类对象访问成员变量：
    （Zi zi = new Zi();）等号左边是谁，就优先用谁，没有则向上找。
间接通过成员方法访问成员变量：
    该方法属于谁，就优先用谁，没有则向上找。

局部变量：         直接写成员变量名
本类的成员变量：    this.成员变量名
父类的成员变量：    super.成员变量名

在父子类的继承关系中，创建子类对象，访问成员方法的规则：
    创建的对象是谁，就优先用谁，如果没有则向上找。

注意事项：
    无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。

重写（Override)（和重载不同）
概念：在继承关系当中，方法的名称一样，参数列表也一样。

重写（Override）：发生在继承当中，方法的名称一样，参数列表【也一样】。覆盖、覆写。
重载（Overload）：方法的名称一样，参数列表【不一样】。

方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。

方法覆盖重写的注意事项：(只有子类才能重写）
1.必须保证父子类之间方法的名称相同，参数列表也相同。
@Override:写在方法前面，用来检测是不是有效的正确覆盖重写。
这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。

2.子类方法的返回值必须【小于等于】父类方法的返回值范围。
小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。

3.子类方法的权限必须【大于等于】父类方法的权限修饰符。
小扩展提示：public > protected > (default) >private
备注：（default)不是关键字default,而是什么都不写，留空。

继承关系中，父子类构造方法的访问特点：

1.子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。
2.子类构造可以通过super关键字来调用父类重载构造。
3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
总结：
子类必须调用父类构造方法：不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。

this(...)调用也必须是构造方法的第一个语句，唯一一个。
super和this两种构造调用，不能同时使用。


抽象类注意事项
1.抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象。
    理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。
2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的
    理解：子类的构造方法中，有默认的super(),需要访问父类构造方法。
3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
    理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。
4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
    理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。


接口就是多个类的公共规范。
接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。

如何定义一个接口的格式：
public interface 接口名称{
    // 接口内容
}

备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java -->.class

如果是Java 7,那么接口中可以包含的内容有：
1.常量
2.抽象方法

如果是Java 8,还可以额外包含有：
3.默认方法
4.静态方法

如果是Java 9,还可以额外包含有：
5.私有方法：private

接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
这两个关键字修饰符，可以选择性地省略。

接口中的“成员变量”：public static final 数据类型 常量名称
接口中的“成员方法”：public default 返回值类型 方法名称（参数列表）{方法体}// import test.demodefault.Main;
注意：
一旦使用final关键字进行修饰，说明不可改变。

接口内容小结
从Java 9+版本中，接口的内容可以有：

1.成员变量其实是常量，格式：
[public] [static] [final] 数据类型 常量名称 = 数据值；
注意：
    常量必须进行赋值，而且一旦赋值不能改变。
    常量名称完全大写，用下划线进行分隔。

2.接口中最重要的就是抽象方法，格式：
[public] [abstract] 返回值类型 方法名称（参数列表）；
注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。

3.从Java 8开始，接口里允许定义默认方法，格式：
[public] default 返回值类型 方法名称（参数列表）{ 方法体}
注意：默认方法也可以被覆盖重写

4.从Java 8开始，接口里允许定义静态方法，格式：
[public] static 返回值类型 方法名称（参数列表）{ 方法体 }
注意：应该通过接口名称进行调用，不能通过实现类对象调用静态方法

5.从Java 9开始，接口里允许定义私有方法，格式：
普通私有方法：private 返回值类型 方法名称（参数列表）{ 方法体 }
静态私有方法：private static 返回值类型 方法名称（参数列表）{ 方法体 }
注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。


代码当中体现多态性，其实就是一句话：父类引用指向子类对象。(向上转型）
格式：
父类名称 对象名 = new 子类名称();（子类方法不能调用）
或者：
接口名称 对象名 = new 实现类名称();

如何才能知道一个父类引用的对象，本来是什么子类？
格式：
对象 instanceof 类名称
这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。


对于类、方法来说，abstract关键字和final关键字不能同时使用，
因为abstract必须覆盖重写，而final修饰的方法/类就是最终方法/类，不能被覆盖重写/继承


如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。例如：身体和心脏的关系

分类：
1.成员内部类
2.局部内部类（包含匿名内部类）

成员内部类的定义格式：
修饰符 class 外部类名称{
    修饰符 class 内部类名称{
        //...
    }
    //...
}

注意：内用外，随意访问；外用内，需要内部类对象。

=====================

如何使用成员内部类？有两种方式：
1.间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。
2.直接方式，公式：
类名称 对象名 = new 类名称();
外部类名称.内部类名称 对象名 = new 外部类名称().内部类名称();

如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，
那么这种情况下就可以省略掉该类的定义，而改为使用[匿名内部类]

匿名内部类的定义格式：
接口名称 对象名 = new 接口名称(){
    // 覆盖重写所有抽象方法
};


================

线程优先级
·最高优先级：public static final int MAX PRIORITY,10;

·中等优先级：public static final int NORM PRIORITY,5;

·最低优先级：public static final int MIN PRIORITY,1;

主线程是属于中等优先级，而默认创建的线程也是中等优先级。优先级高的可能先执行而不是绝对先执行。